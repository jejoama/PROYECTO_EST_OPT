---
title: "pr_fabian"
author: "Fabián Calvo Castillo"
date: "2025-12-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# EXTRACCIÓN DEL DATATSET

```{r}
train <- read.csv("stock_returns_train_2.csv")

# Serie temporal
train_serie <- ts(train)
train_serie<- ts(train/100)
summary(train_serie)

```

#DIVISIÓN TRAIN vs. TEST

```{r}
filas_train <- nrow(train)

#Hemos pensando en dividirlo en 80% train vs 20% Test

#Entrenamiento --> 96 primeros
Xtrain <- window(train_serie, start=1, end=floor(0.8*filas_train))

# Validación: 24 ultimos
Xtest <- window(train_serie, start=floor(0.8*filas_train)+1, end=filas_train)

```



PASO 2
Nos pide tanto la varianza como el valor esperado de neustra estimación. Haciendolo de modo que en nuestro tiempo t, cojamos todo lo del pasado --> t-1... --> para ello Modelo ARIMA
```{r}
library(forecast)  
library(FinTS)    

# Modelo arima para el activo 1: x1
for (i in 1:ncol(train_serie)){
  x_train <- Xtrain[,i]  
  
  fit_arima <- auto.arima(x_train, seasonal = FALSE)

  #Ljung-Box sobre los residuos - (autocorrelación hasta lag=20)
  Box_test <- Box.test(residuals(fit_arima), lag=20, type="Ljung-Box")
  
  
  #ARCH sobre los residuos ---
  arch_test <- ArchTest(residuals(fit_arima), lags=20)
  print(Box_test)
  print(arch_test)
  print("--------------")
}

```

MODELO ARIMA
```{r}
# getPred <- function(x_train, x_test_past){
#   # Modelo ARIMA simple
#   mod <- arima(x_train, order=c(1,0,0))
#   x_past <- c(x_train, x_test_past)
#   fit_upd <- forecast::Arima(x_past, model = mod)
#   fc <- forecast::forecast(fit_upd, h = 1)
# 
#   mu_hat <- as.numeric(fc$mean[1])
#   z80 <- qnorm(0.8)
#   se_from_up <- (fc$upper[,"80%"][1] - fc$mean[1]) / z80
#   se_from_lo <- (fc$mean[1] - fc$lower[,"80%"][1]) / z80
#   se_hat <- as.numeric(pmax(se_from_up, se_from_lo))
# 
#   return(list(mu_hat=mu_hat, se_hat=se_hat))
# }

getPred <- function(x_train, x_test_past){
  
  x_past <- c(x_train, x_test_past)

  fit <- auto.arima(x_past, seasonal = FALSE, stationary = TRUE)
  
  fc <- forecast::forecast(fit, h = 1)
  
  mu_hat <- as.numeric(fc$mean)
  
  var_hat <- fit$sigma2 
  
  se_hat <- sqrt(fit$sigma2) 

  return(list(mu_hat = mu_hat, se_hat = se_hat))
}

```


2.2
```{r}
getPred_ts <- function(Xtrain, Xtest, getPredFunc){
  H <- nrow(Xtest)
  mu_hat <- matrix(NA, H, 5)
  se_hat <- matrix(NA, H, 5)
  X_test_past <- Xtest[0,]

  for (h in seq_len(H)) {
    for (i in 1:5){
      pred <- do.call(getPredFunc, list(Xtrain[,i], X_test_past[,i]))
      mu_hat[h,i] <- pred$mu_hat
      se_hat[h,i] <- pred$se_hat
    }
    X_test_past <- Xtest[1:h,,drop=FALSE]
  }
  return(list(mu_hat=mu_hat, se_hat=se_hat))
}

# Ejecutar predicciones
res <- getPred_ts(Xtrain, Xtest, getPred)
mu_hat <- res$mu_hat
se_hat <- res$se_hat
res
mu_hat
se_hat

```


aplicacion de la funcion que hemos definido a mis datis 
```{r}
# Usamos la función auxiliar de los ejemplos
res <- getPred_ts(Xtrain, Xtest, getPred)

# Guardamos resultados
mu_hat <- res$mu_hat   # valores esperados
se_hat <- res$se_hat   # varianzas
head(mu_hat)
head(se_hat)

# Revisar dimensiones
dim(mu_hat)  # debería ser (nrow(Xtest), 5)
dim(se_hat)  # igual

```

```{r}
mape <- mean(abs(Xtest - mu_hat) / abs(Xtest))
print(paste("MAPE promedio:", round(mape,4)))

```

2.3
```{r}
# Función recursiva para aplicar getPred en todo el test
getPred_ts <- function(Xtrain, Xtest, getPredFunc){
  H <- nrow(Xtest)         # número de periodos en test
  mu_hat <- matrix(NA, H, 5)  # matriz de valores esperados
  se_hat <- matrix(NA, H, 5)  # matriz de varianzas
  X_test_past <- Xtest[0,]    # inicializamos vacío

  for (h in seq_len(H)) {
    for (i in 1:5){
      # pronóstico para activo i en instante h
      pred <- do.call(getPredFunc, list(Xtrain[,i], X_test_past[,i]))
      mu_hat[h,i] <- pred$mu_hat
      se_hat[h,i] <- pred$se_hat
    }
    # actualizamos histórico con el dato observado en test
    X_test_past <- Xtest[1:h,,drop=FALSE]
  }
  return(list(mu_hat=mu_hat, se_hat=se_hat))
}

# Ejecut
res <- getPred_ts(Xtrain, Xtest, getPred)

mu_hat <- res$mu_hat   # valores esperados
se_hat <- res$se_hat   # varianzas


head(mu_hat)
head(se_hat)
```

2.4 Función oneStepAhead
```{r}
oneStepAhead <- function(Xtrain, Xtest_past, getPredFunc){
  n <- ncol(Xtrain)
  mu_hat <- numeric(n_assets)
  se_hat <- numeric(n_assets)
  
  for (i in 1:n){
    pred <- do.call(getPredFunc, list(Xtrain[,i], Xtest_past[,i]))
    mu_hat[i] <- pred$mu_hat
    se_hat[i] <- pred$se_hat
  }
  
  return(list(mu_hat = mu_hat, se_hat = se_hat))
}

```

```{r}
#Apartado Irene
```
# APARTADO 3: Utilidad Media-Varianza
Queremos averiguar cuánto queremos invertir en cada activo (calcular \alpha_t) para t= T+1,..., T+r. Para ello tenemos que optimizar la función UMV(alpha_t) donde, en este primer apartado, alpha puede tomar valores negativos (tomar una posición corta).

Primero vamos a calcular la matriz de covarianza de los rendimientos de los 5 activos \Sigma_t=DRD, donde D es la matriz diagonal con las desviaciones estándar de cada activo y R es la matriz de correlación.
```{r}
#sd <- apply(Xtrain, 2, sd) # desviación estándar de cada activo (el 2 para que aplique sobre cada columna)
#D <- diag(sd)
R <- cor(Xtrain)
#Sigma_t <- D %*% R %*% D
#print(Sigma_t)
```

Ahora vamos a determinar los \alpha_t usando UMV.
\mu_t son los valores esperados de los rendimientos del apartado anterior.
```{r}
UMV <- function(alpha, mu, gamma, sigma){
  E_R <- t(alpha) %*% mu # valor esperado del rendimiento
  V_R <- t(alpha) %*% sigma %*% alpha # varianza del rendimiento
  umv <- E_R-gamma/2*V_R # utilidad media-varianza
  # gamma pequeño, mayor riesgo para obtener mayor rendimiento
  return(as.numeric(umv))
}

# maximizando UMV (queremos mayor rendimiento, menor riesgo), obtenemos alpha
alpha_opt <- function(gamma, sigma, mu){
  vec <- rep(1, 5)
  lambda <- (t(vec) %*% solve(sigma) %*% mu - gamma)/(t(vec) %*% solve(sigma) %*% vec)
  alpha <- 1/gamma*solve(sigma) %*% (mu-as.numeric(lambda)*vec)
  return(as.numeric(alpha))
}
```

Calculamos alpha_t para cada periodo
```{r}
matriz_alpha <- matrix(NA, nrow=nrow(mu_hat), ncol=5)

# # para gamma=1
# for (i in 1:nrow(mu_hat)){
#   matriz_alpha[i,] <- alpha_opt(1, Sigma_t, mu_hat[i,])
# }
# head(matriz_alpha)

# para gamma=1
for (i in 1:nrow(mu_hat)){
  D <- diag(se_hat[i,])
  Sigma_t <- D %*% R %*% D

  matriz_alpha[i,] <- alpha_opt(1, Sigma_t, mu_hat[i,])
}
head(matriz_alpha)
```

Calculamos el rendimiento R
```{r}
R_t <- rep(NA, nrow(mu_hat))

for (i in 1:nrow(mu_hat)){
  R_t[i] <- sum(matriz_alpha[i,]*Xtest[i,])
}
R_t <- R_t/100
print(R_t)
```

Rendimiento total
```{r}
I0 <- 100 # inversión inicial
R <- I0*cumprod(1+R_t)
print(R)
```


```{r}
# FUNCIONES DADAS POR EMILIANO

# obtener alpha_t en funcion de mu_t, sig_t, gamma y la funcion Sigma(sig_t, Xpast) elegida
getAlpha <- function(mu,sig, gamma, getSigmaFunc, getAlphaFunc, Xpast){
  Sigma <- do.call(getSigmaFunc, list(sig, Xpast))
  alpha <- do.call(getAlphaFunc, list(mu, Sigma, gamma))
  return(alpha)  
}

# obtener alpha para todo periodo de test
getAlpha_ts <- function(mus, sigs, gamma, getSigmaFunc, getAlphaFunc, Xtrain, Xtest){
  H <- nrow(Xtest)
  alpha_hat <- matrix(NA, H, 5)
  Xpast <- as.matrix(Xtrain)
  for (h in seq_len(H)) {
    alpha_hat[h,] <- getAlpha(mus[h,], sigs[h,], gamma, getSigmaFunc, getAlphaFunc, Xpast)
    dato_hoy<-as.matrix(Xtest[h,])
    Xpast <- rbind(Xpast, Xtest[h,])
  }  
  return(alpha_hat)
}

# funcion para checar si las alfas cumplen los requisitos segun el inciso
getChecks <- function(alpha_hat, mode=c("sum1","pos")){
  passChecks <- TRUE
  if(("sum1" %in% mode) & passChecks){
    #print("sum1 check")
    passChecks <- all( (apply(alpha_hat, 1, sum)-1) <1e-6)
  }
  if(("pos" %in% mode) & passChecks){
    #print("pos check")
    passChecks <- all(alpha_hat>=0)
  }
  return(passChecks)
}

# obtener el rendimeinto del portafolio
getRet <- function(alpha_hat, Xtest, passChecks){
  if(!passChecks) return(NA)
  Xtest_mat <- as.matrix(Xtest)
  ret <-prod(1+apply(alpha_hat*(Xtest_mat/100), 1, sum))-1
  return(ret)
}
```

```{r}
# Para el modelo MV: Sigma = D * R * D
getSigmaMV <- function(sig, Xpast){
  R <- cor(Xpast, use="pairwise.complete.obs") 
  D <- diag(sig)  
  Sigma <- D %*% R %*% D
  return(Sigma)
}

# Para el modelo MV Positivo (usualmente es la misma lógica de riesgo)
getSigmaMVPos <- function(sig, Xpast){
  return(getSigmaMV(sig, Xpast))
}

# APARTADO 3.1: Con Posiciones Cortas
getAlphaRandom <- function(mu, Sigma, gamma){
  vec <- rep(1, length(mu))
  invSigma <- solve(Sigma)
  
  # Cálculo de Lambda y Alpha óptimo
  lambda <- (t(vec) %*% invSigma %*% mu - gamma) / (t(vec) %*% invSigma %*% vec)
  alpha <- (1/gamma) * invSigma %*% (mu - as.numeric(lambda) * vec)
  
  return(as.numeric(alpha))
}

# APARTADO 3.2: Sin Posiciones Cortas (Quadprog)
library(quadprog)

getAlphaRandomPos <- function(mu, Sigma, gamma){
  n <- length(mu)
  
  # Configuración para solve.QP
  Dmat <- gamma * Sigma #+ diag(1e-8, n) # Ajuste numérico
  dvec <- mu
  Amat <- cbind(rep(1, n), diag(n))     # Restricciones: Suma=1, I>=0
  bvec <- c(1, rep(0, n))               # Valores: 1, 0, 0, 0...
  
  # Resolución numérica
  res <- tryCatch({
    sol<- solve.QP(Dmat, dvec, Amat, bvec, meq=1)
    sol$solution
  }, error = function(e) {
    return(rep(1/n, n)) # Si falla, pesos iguales
  })
  res[res < 0] <- 0 
  res <- res / sum(res)
  
  return(res)
}
```

```{r}
# Definimos Gamma (aversión al riesgo)
gamma_param <- 1 

# APARTADO 3.1: Optimización CON posiciones cortas
print("--- RESULTADOS APARTADO 3.1 (CON CORTOS) ---")

# Ejecutamos el código de Emiliano usando las piezas MV (Lagrange)
alpha_3_1 <- getAlpha_ts(
  mus = mu_hat, 
  sigs = se_hat, 
  gamma = gamma_param,
  getSigmaFunc = getSigmaMV, 
  getAlphaFunc = getAlphaRandom, 
  Xtrain = Xtrain, 
  Xtest = Xtest
)

# Validamos (solo check de suma=1, permitimos negativos)
check_3_1 <- getChecks(alpha_3_1, mode=c("sum1"))
print(paste("¿Cumple restricciones?:", check_3_1))

# Rendimiento
ret_3_1 <- getRet(alpha_3_1, Xtest, check_3_1)
print(paste("Rendimiento Final Acumulado:", round(ret_3_1 * 100, 2), "%"))
```

```{r}
# APARTADO 3.2: Optimización SIN posiciones cortas (Solo largos)
print(" ")
print("--- RESULTADOS APARTADO 3.2 (SIN CORTOS) ---")


alpha_3_2 <- getAlpha_ts(
  mus = mu_hat, 
  sigs = se_hat, 
  gamma = gamma_param,
  getSigmaFunc = getSigmaMV,   
  getAlphaFunc = getAlphaRandomPos,
  Xtrain = Xtrain, 
  Xtest = Xtest
)


check_3_2 <- getChecks(alpha_3_2, mode=c("sum1", "pos"))
print(paste("¿Cumple restricciones (Suma=1 y Positivos)?:", check_3_2))


ret_3_2 <- getRet(alpha_3_2, Xtest, check_3_2)
print(paste("Rendimiento Final Acumulado:", round(ret_3_2 * 100, 2), "%"))
```

